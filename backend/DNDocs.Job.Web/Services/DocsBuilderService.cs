
using DNDocs.Api.Client;
using DNDocs.Api.Model.Integration;
using DNDocs.Docs.Api.Client;
using DNDocs.Job.Api.Management;
using DNDocs.Job.Web.Shared;
using DNDocs.Job.Web.ValueTypes;
using Ganss.Xss;
using Markdig;
using Microsoft.Extensions.Logging.Configuration;
using Microsoft.Extensions.Options;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO.Compression;
using System.Reflection;
using System.Runtime.InteropServices;
using Vinca.Api;
using Vinca.Api.Nuget;
using Vinca.Exceptions;
using Vinca.Utils;
using static DNDocs.Job.Api.Management.BuildProjectModel;

namespace DNDocs.Job.Web.Services
{
    public interface IDocsBuilderService
    {
        Task Handle(BuildProjectModel p);
    }

    public class DocsBuilderService : IDocsBuilderService
    {
        private IDNClient dnclient;
        private DJobSettings settings;
        private INugetRepositoryFacade nugetRepositoryFacade;
        private ILogger<DocsBuilderService> logger;
        private IDDocsApiClient ddocsApiClient;
        private IOSApi osapi;
        private IDocfxManager docfxManager;

        public DocsBuilderService(
            ILogger<DocsBuilderService> logger,
            IDDocsApiClient ddocsApiClient,
            IOSApi osapi,
            IDocfxManager docfxManager,
            INugetRepositoryFacade nugetRepositoryFacade,
            IOptions<DJobSettings> settings,
            IDNClient dnclient)
        {
            this.dnclient = dnclient;
            this.settings = settings.Value;
            this.nugetRepositoryFacade = nugetRepositoryFacade;
            this.logger = logger;
            this.ddocsApiClient = ddocsApiClient;
            this.osapi = osapi;
            this.docfxManager = docfxManager;
        }

        public async Task Handle(BuildProjectModel project)
        {
            Exception exception = null;

            try
            {
                logger.LogInformation("starting to build project id: {0}", project.ProjectId);

                using var tempFolder = osapi.CreateTempDir();

                docfxManager.Init(tempFolder.OSFullPath, project);

                FetchNugetXmlAndDlls(project.ProjectNugetPackages, docfxManager.OSPathBinDir);
                FetchMdDocs(project, docfxManager.OSPathIndexHtml, docfxManager.OSPathArticlesDir);

                string homepageContent, apiHomepageContent, articlesHomepageContent, appTitle;

                if (project.ProjectType == ProjectType.NugetOrg)
                {
                    appTitle = $"{project.NugetOrgPackageName} {project.NugetOrgPackageVersion} | {settings.Strings.DNDocs}";
                    articlesHomepageContent = apiHomepageContent = homepageContent = 
                        $"# Welcome on {project.NugetOrgPackageName} {project.NugetOrgPackageVersion} API\r\n" +
                        $"#### Generated by [DNDocs]({settings.DNServerUrl})";
                }
                else if (project.ProjectType == ProjectType.Version)
                {
                    appTitle = $"{project.ProjectName} {project.PVGitTag} | {settings.Strings.DNDocs}";

                    articlesHomepageContent = apiHomepageContent = homepageContent =
                        $"# Welcome on {project.ProjectName} {project.PVProjectVersioningId} API\r\n" +
                        $"#### Generated by [DNDocs]({settings.DNServerUrl})";

                    articlesHomepageContent = apiHomepageContent = homepageContent;
                }
                else if (project.ProjectType == ProjectType.Singleton)
                {
                    appTitle = $"{project.ProjectName} | {settings.Strings.DNDocs}";

                    articlesHomepageContent = apiHomepageContent = homepageContent =
                        $"# Welcome on {project.ProjectName} API \r\n" +
                        (project.GithubUrl == null ? "" : $"##[{project.GithubUrl}]({project.GithubUrl}] \r\n") +
                        $"### Generated for Nuget Packages \r\n" +
                        "| Package Id | Package Version | \r\n" +
                        "|:------:|:-------:| \r\n" +
                        project.ProjectNugetPackages?.StringJoin("\r\n", n => $"| {n.IdentityId} | {n.IdentityVersion} |") +
                        "\r\n" +
                        $"#### Generated by [DNDocs]({settings.DNServerUrl}) \r\n";
                }
                else throw new NotImplementedException("projecttype");

                var info = Newtonsoft.Json.JsonConvert.SerializeObject(new
                {
                    projectId = project.ProjectId,
                    isVersioning = project.PVProjectVersioningId.HasValue,
                    buildOnDJobVersion = System.Diagnostics.FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location).ProductVersion
                });

                string appFooter =
                    $"<div id=\"id-dndocs-footer\">" +
                    "<script type=\"application/json\" id=\"id-dndocs-info-json\">" +
                    $"{info}" +
                    "</script>" +
                    $"<script type=\"text/javascript\" src=\"{settings.Strings.UrlDNDocsDocfJsScriptUrl}\"></script>" +
                    "</div>" +
                    "";

                docfxManager.SetDocfxJson(appFooter, appTitle, project.DocfxTemplate);
                docfxManager.SetHomepageContent(homepageContent);
                docfxManager.SetApiHomepageContent(apiHomepageContent);
                docfxManager.SetArticlesHomepageContent(articlesHomepageContent);
                docfxManager.AutogenerateArticlesTOC();
                await StartProcessBuildDocfx(docfxManager.OSPathDocfxJson);

                var toolspath = Path.GetFullPath(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, settings.ConsoleToolsDllFilePath));
                string args = $@"{toolspath} docfx {docfxManager.OSPathDocfxJson}";
                // osapi.ProcessStart("dotnet", args, 240, out var exitcode, out var stdo, out var stderr);

                using (var tempZipFolder = osapi.CreateTempDir())
                {
                    var zipOsPath = Path.Combine(tempZipFolder.OSFullPath, "site.zip");
                    ZipFile.CreateFromDirectory(docfxManager.OSPathSiteDirectory, zipOsPath);

                    using (var zipStream = new FileStream(zipOsPath, FileMode.Open, FileAccess.Read))
                    {
                        logger.LogInformation("uploading to docs.dndocs. id: {0} name: {1} urlprefix: {2} project_type: {3}", project.ProjectId, project.ProjectName, project.UrlPrefix, project.ProjectType);

                        var task = ddocsApiClient.Management_CreateProject(
                            project.ProjectId,
                            project.ProjectName,
                            $"",
                            project.UrlPrefix,
                            project.PVGitTag,
                            project.NugetOrgPackageName,
                            project.NugetOrgPackageVersion,
                            (int)project.ProjectType,
                            zipStream);

                        task.Wait();

                        logger.LogInformation("completed uploading to docs.dndocs. id: {0} name: {1} urlprefix: {2} project_type: {3} ", project.ProjectId, project.ProjectName, project.UrlPrefix, project.ProjectType);

                        var result = task.Result;
                    }
                }

                // send to dndocs.com completed

                docfxManager.CleanAfterBuild();
            }
            catch (Exception e)
            {
                logger.LogError(e, "failed to build");
                exception = e;
            }

            try
            {
                if (exception == null)
                {
                    await dnclient.Integration_DJobBuildCompleted(new DJobBuildCompletedModel { ProjectId = project.ProjectId, Success = true });
                }
                else
                {
                    await dnclient.Integration_DJobBuildCompleted(new DJobBuildCompletedModel
                    {
                        Exception = Helpers.ExceptionToStringForLogs(exception),
                        ProjectId = project.ProjectId,
                        Success = false
                    });
                }
            }
            catch (Exception e)
            {
                // not sure what to do if build success with published on ddocs
                // but failed to inform dn that it was success
                logger.LogError(e, "Build and publish project success but failed to send to DNDocs information");
            }
            
        }

        private async Task StartProcessBuildDocfx(string osPathDocfxJson)
        {
            // just run docfx process, rest are logs or cancellation
            string stdo = "";
            string stderr = "";
            string plog = $"Process Info: docfx os path: {osPathDocfxJson}";
            string toolspath = Path.GetFullPath(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, settings.ConsoleToolsDllFilePath));
            int maxProcessWait5Min = 5 * 60 * 1000;

            using (Process p = new Process())
            {
                try
                {
                    p.StartInfo.FileName = "docfx";
                    p.StartInfo.Arguments = @$"{osPathDocfxJson}";
                    if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
                    {
                        p.StartInfo.FileName = "/root/.dotnet/tools/docfx";
                        // p.StartInfo.FileName = "bash";
                        // p.StartInfo.FileName = $"-c \"docfx {osPathDocfxJson}\"";
                    }
                    p.StartInfo.UseShellExecute = false;
                    p.StartInfo.RedirectStandardOutput = true;
                    p.StartInfo.RedirectStandardError = true;
                    p.StartInfo.WorkingDirectory = null;
                    p.OutputDataReceived += (s, e) => stdo += e.Data;
                    p.ErrorDataReceived += (s, e) => stderr += e.Data;

                    bool started = p.Start();

                    p.BeginOutputReadLine();
                    p.BeginErrorReadLine();

                    plog += string.Format("PID: {0}, PSI_ARGS: {1}, PSTART: {2}", p.Id, p.StartInfo.Arguments, started);

                    CancellationTokenSource cts = new CancellationTokenSource();

                    cts.CancelAfter(maxProcessWait5Min);

                    logger.LogInformation("starting process and waiting for exit. {0}", plog);

                    var sw = Stopwatch.StartNew();
                    await p.WaitForExitAsync(cts.Token);
                    //stdo = await p.StandardOutput.ReadToEndAsync();
                    //stderr = await p.StandardError.ReadToEndAsync();

                    VValidate.AppEx(!p.HasExited, "process did not exits");
                    VValidate.AppEx(p.ExitCode != 0, "process exit code not zero");
                    VValidate.AppEx(!stdo.Contains("0 error(s)"), "docfx std output does not contain '0 error(s)' string");

                    logger.LogInformation("process successfully exited, pinfo  {0}, stdo: {1}, stderr: {2}, ellapsed ms: {3}", plog, stdo, stderr, sw.ElapsedMilliseconds);
                }
                catch (Exception e)
                {
                    logger.LogError(e, "failed to wait for process, hasexited: {0}, exitcode: {1} pinf: {1}, stdo: {2}, stderr: {3}",
                        p.HasExited, p.HasExited ? p.ExitCode.ToString() : "(not exited)", plog, stdo, stderr);

                    try
                    {
                        logger.LogInformation("starting to kill process:  {0}", plog);
                        p.Kill();
                        logger.LogInformation("kill process completed success: {0}", plog);
                    }
                    catch (Exception killException)
                    {
                        logger.LogError(killException, "failed to kill process");
                    }

                    throw;
                }
            }
        }

        void FetchNugetXmlAndDlls(List<NugetPackage> newPackages, string outputFolder)
        {
            logger.LogTrace("starting to fetch nugetxmlanddll");

            foreach (var package in newPackages)
            {
                try
                {
                    var packageBinData = nugetRepositoryFacade.FetchDllAndXmlFromPackage(package.IdentityId, package.IdentityVersion);

                    foreach (var item in packageBinData)
                    {
                        File.WriteAllBytes(Path.Combine(outputFolder, item.FileName), item.ByteData);
                    }
                }
                catch (Exception e)
                {
                    logger.LogError(e, "failed to fetch nuget packages");

                    throw e;
                }
            }
        }


        //ngm._appFooter =
        //    "" +
        //    "<div style=\"width: 100%\">" +
        //    "<div style=\"display: flex; align-items: center; \">" + 
        //    $"    <div style=\"flex: 1;\">{versionsHtml}</div>" +
        //    "    <div>" +
        //    $"     <a href=\"https://{wwwrobinia}\">Hosted with {robiniaName}</a>" +
        //    "      <span style=\"display: inline-block; margin: 0 0.5em;\">|</span>" +
        //    "      <a href=\"https://dotnet.github.io/docfx\">Docfx</a>" +
        //    "    </div>" +
        //    "    <div style=\"flex: 1;\"></div>" +
        //    "</div>" +
        //    $"<script type=\"text/javascript\" src=\"{options.DndocsDocfxScriptUrl}\"></script>" +
        //    "</div>" +
        //    "";

        //private IGit GetGit(Project project)
        //{
        //    IGit git = appManager.OpenGitRepo(project.GitMdRepoUrl);
        //    git.CheckoutBranch(project.GitMdBranchName);
        //    git.Pull();

        //    return git;
        //}

        private void FetchMdDocs(BuildProjectModel project, string outputReadmeFilePath, string outputArticlesFolder)
        {
            if (string.IsNullOrWhiteSpace(project.GitMdRepoUrl)) return;
            throw new NotImplementedException();

            // using (var git = GetGit(project))
            // {
            //     FetchMdDocs2(project, outputReadmeFilePath, outputArticlesFolder, git);
            // }
        }

        //private void FetchMdDocs2(Project project, string outputReadmeFilePath, string outputArticlesFolder, IGit git)
        //{
        //    if (string.IsNullOrWhiteSpace(project.GitMdRelativePathReadme) && string.IsNullOrWhiteSpace(project.GitMdRelativePathDocs))
        //        return;

        //    VValidate.Throw(string.IsNullOrWhiteSpace(project.GitDocsCommitHash), "git commit hash empty cannot build docs (application exception)");

        //    git.PruneRemote();
        //    git.FetchAll();
        //    git.CheckoutBranch(project.GitMdBranchName);
        //    git.Pull();
        //    git.CheckoutCommit(project.GitDocsCommitHash);
        //    string projectRepoOsPath = git.RepoOSPath;

        //    // TODO: this  is expensive to create,
        //    // but not sure if this is thread safe, maybe create static prop and use semaphore for building all concurrent project??
        //    // only in single thread?

        //    var pp = (new Markdig.MarkdownPipelineBuilder())
        //        .UseAdvancedExtensions()
        //        .Build();

        //    var htmlSanitizer = new HtmlSanitizer();

        //    if (!string.IsNullOrWhiteSpace(project.GitMdRelativePathDocs))
        //    {
        //        // first directory has all project files
        //        var docsRelPath = project.GitMdRelativePathDocs;
        //        string articlesInRepoFolderOSPath = Path.Combine(projectRepoOsPath, docsRelPath);

        //        if (!Directory.Exists(articlesInRepoFolderOSPath))
        //        {
        //            var userMsg = $"Directory '{docsRelPath}' (relative path) does not exists in repo folder\n " +
        //               $"{project}\nGit Branch Name: {project.GitMdBranchName}\nGitDocsCommitHash: {project.GitDocsCommitHash}";

        //            logger.LogError($"{userMsg}\nospathRepo:{projectRepoOsPath};\nGithubMdRelativePathDocs: {docsRelPath}");
        //            VValidate.ThrowError(true, userMsg);
        //        }

        //        string[] articles = Directory.GetFiles(articlesInRepoFolderOSPath, "*.md", SearchOption.AllDirectories);

        //        foreach (var mdOsPath in articles)
        //        {
        //            var md = File.ReadAllText(mdOsPath);
        //            var mdHtml = Markdig.Markdown.ToHtml(md, pp);
        //            mdHtml = htmlSanitizer.Sanitize(mdHtml);
        //            var fileRelativePath = mdOsPath.Substring(articlesInRepoFolderOSPath.Length + 1);

        //            var saveOsPath = Path.Combine(outputArticlesFolder, fileRelativePath);
        //            var saveOsDir = Path.GetDirectoryName(saveOsPath);

        //            if (!Directory.Exists(saveOsDir))
        //                Directory.CreateDirectory(saveOsDir);

        //            File.WriteAllText(saveOsPath, mdHtml);
        //        }
        //    }

        //    if (!string.IsNullOrWhiteSpace(project.GitMdRelativePathReadme))
        //    {
        //        var readmeRelPath = project.GitMdRelativePathReadme;
        //        var readmeOsPath = Path.Combine(projectRepoOsPath, readmeRelPath);
        //        VValidate.ThrowError(!File.Exists(readmeOsPath), $"Readme file '{readmeRelPath}' does not exists in repo folder");
        //        string readmeMdFileContent = File.ReadAllText(readmeOsPath);

        //        var homeContentHtml = Markdig.Markdown.ToHtml(readmeMdFileContent, pp);
        //        File.WriteAllText(outputReadmeFilePath, homeContentHtml);
        //    }
        //}
    }
}
